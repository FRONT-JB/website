---
title: 📝 GitHub Actions로 CHANGELOG 자동 생성하는 완벽 가이드
authors: [jb]
description: "GitHub Actions와 Conventional Commits로 CHANGELOG를 자동화하는 방법을 알아보세요. standard-version과 release-please를 사용한 실전 워크플로우를 단계별로 설명합니다."
tags: ["Frontend", "GitHub Actions", "CI/CD", "DevOps"]
image: "/blog/change-log.png"
date: 2026-02-10
---

# GitHub Actions로 CHANGELOG 자동 생성하는 완벽 가이드

커밋 내역을 일일이 확인하고, 변경 사항을 정리하고, 버전별로 분류하는 작업은 시간이 많이 걸려요.

이 글에서는 GitHub Actions를 사용해서 CHANGELOG 생성을 완전히 자동화하는 방법을 다룹니다. Conventional Commits 규칙과 자동화 도구를 활용하면 릴리즈마다 깔끔한 CHANGELOG가 자동으로 만들어져요.

이 글은 GitHub Actions를 한 번이라도 사용해본 개발자를 대상으로 합니다.

## 왜 CHANGELOG를 자동화해야 할까요?

수동으로 CHANGELOG를 작성하면 다음과 같은 문제가 생겨요.

**시간 낭비와 실수**

릴리즈마다 커밋 히스토리를 확인하고 변경 사항을 정리하는 데 시간이 걸려요. 중요한 커밋을 놓치거나 잘못된 정보를 기록할 수도 있죠.

**일관성 부족**

작성자마다 형식이 달라지고, 중요도 판단이 달라져요. 팀원들이 CHANGELOG를 신뢰하지 못하게 됩니다.

**자동화의 이점**

GitHub Actions로 자동화하면 다음과 같은 이점이 있어요.

- 릴리즈마다 일관된 형식의 CHANGELOG 생성
- 커밋 메시지 기반으로 자동 분류 (새 기능, 버그 수정, 문서 등)
- 버전 태그와 함께 자동으로 GitHub Release 생성
- 개발자는 코드에만 집중하고 CHANGELOG는 자동으로 관리

## Conventional Commits 규칙 빠르게 이해하기

CHANGELOG 자동화의 핵심은 **Conventional Commits** 규칙이에요. 커밋 메시지를 일정한 형식으로 작성하면 자동화 도구가 이를 파싱해서 CHANGELOG를 생성해요.

### 커밋 메시지 형식

기본 형식은 다음과 같아요.

```bash
<타입>(<범위>): <제목>

<본문>

<푸터>
```

**타입**은 변경 사항의 종류를 나타내요.

- `feat` - 새로운 기능 추가
- `fix` - 버그 수정
- `docs` - 문서 변경
- `style` - 코드 포맷팅, 세미콜론 누락 등 (기능 변경 없음)
- `refactor` - 코드 리팩토링
- `test` - 테스트 추가 또는 수정
- `chore` - 빌드 프로세스, 도구 설정 변경

**범위**는 선택 사항이며, 변경된 모듈이나 파일을 나타내요.

**제목**은 변경 사항을 간단히 설명해요.

### 실제 사용 예시

다음은 실제 프로젝트에서 사용하는 커밋 메시지 예시예요.

```bash
feat(auth): 로그인 기능 추가

사용자가 이메일과 비밀번호로 로그인할 수 있습니다.

Closes #123
```

```bash
fix(api): 사용자 조회 API 버그 수정

null 체크 누락으로 인한 500 에러를 수정했습니다.
```

```bash
docs: README에 설치 가이드 추가
```

<Callout>
**Breaking Change 표시하기**

하위 호환성을 깨는 변경 사항은 푸터에 `BREAKING CHANGE:`를 추가하거나 타입 뒤에 `!`를 붙여요.

```bash
feat!: API 응답 형식 변경

BREAKING CHANGE: API 응답이 { data } 형식으로 변경되었습니다.
```

</Callout>

## GitHub Actions 워크플로우 작성하기

이제 CHANGELOG를 자동으로 생성하는 GitHub Actions 워크플로우를 만들어볼게요.

### 워크플로우 파일 생성

프로젝트 루트에 `.github/workflows/` 디렉토리를 만들고 `release.yml` 파일을 생성하세요.

```bash
mkdir -p .github/workflows
touch .github/workflows/release.yml
```

### 트리거 설정

워크플로우가 실행될 시점을 정의해요. 일반적으로 `main` 브랜치에 푸시될 때 또는 수동으로 실행할 수 있게 설정해요.

```yaml
# .github/workflows/release.yml
name: Release

on:
  push:
    branches:
      - main
  workflow_dispatch: # 수동 실행 허용
```

## CHANGELOG 자동 생성 구현

CHANGELOG를 자동으로 생성하는 방법은 크게 두 가지예요. `standard-version`과 `release-please` 중 하나를 선택할 수 있어요.

### 방법 1 - standard-version 사용

`standard-version`은 Conventional Commits 기반으로 버전을 올리고 CHANGELOG를 생성하는 도구예요.

**장점**

- 간단한 설정
- npm 프로젝트에 최적화
- 커스터마이징 가능

**전체 워크플로우**

```yaml
# .github/workflows/release.yml
name: Release

on:
  workflow_dispatch: # 수동 실행

jobs:
  release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout 코드
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # 전체 히스토리 가져오기
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Node.js 설정
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: 의존성 설치
        run: npm install

      - name: Git 설정
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: standard-version 실행
        run: npx standard-version

      - name: 변경사항 푸시
        run: |
          git push --follow-tags origin main
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: GitHub Release 생성
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          body_path: CHANGELOG.md
```

`standard-version`을 실행하면 다음과 같은 작업이 자동으로 수행돼요.

1. 이전 버전 이후의 모든 커밋 분석
2. Conventional Commits 규칙에 따라 버전 결정 (major, minor, patch)
3. CHANGELOG.md 업데이트
4. package.json 버전 업데이트
5. Git 태그 생성

### 방법 2 - release-please 사용

`release-please`는 Google에서 만든 자동화 도구로, Pull Request 기반으로 릴리즈를 관리해요.

**장점**

- PR로 릴리즈 검토 가능
- 여러 언어 지원 (Node.js, Python, Go 등)
- 자동으로 GitHub Release 생성

**전체 워크플로우**

```yaml
# .github/workflows/release-please.yml
name: Release Please

on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

jobs:
  release-please:
    runs-on: ubuntu-latest

    steps:
      - uses: google-github-actions/release-please-action@v4
        with:
          release-type: node # 프로젝트 타입 (node, python, go 등)
          package-name: my-package # 패키지 이름
```

`release-please`는 다음과 같이 동작해요.

1. `main` 브랜치에 푸시될 때마다 실행
2. Conventional Commits 분석
3. Release PR 생성 (CHANGELOG 미리보기 포함)
4. Release PR이 머지되면 자동으로 태그 생성 및 GitHub Release 생성

<Callout type="info" title="어떤 방법을 선택할까?">
  **standard-version**은 간단한 프로젝트에 적합하고, **release-please**는 릴리즈 전 검토가 필요한 팀 프로젝트에 적합해요.

- 개인 프로젝트, 빠른 릴리즈 → standard-version
- 팀 프로젝트, 릴리즈 검토 필요 → release-please

</Callout>

## 고급 설정

### CHANGELOG 템플릿 커스터마이징

`standard-version`을 사용하는 경우 `.versionrc.json` 파일로 CHANGELOG 템플릿을 커스터마이징할 수 있어요.

```json
// .versionrc.json
{
  "types": [
    { "type": "feat", "section": "✨ Features" },
    { "type": "fix", "section": "🐛 Bug Fixes" },
    { "type": "docs", "section": "📝 Documentation" },
    { "type": "style", "section": "💄 Styles" },
    { "type": "refactor", "section": "♻️ Code Refactoring" },
    { "type": "perf", "section": "⚡️ Performance Improvements" },
    { "type": "test", "section": "✅ Tests" },
    { "type": "chore", "section": "🔧 Chores" }
  ],
  "commitUrlFormat": "{{host}}/{{owner}}/{{repository}}/commit/{{hash}}",
  "compareUrlFormat": "{{host}}/{{owner}}/{{repository}}/compare/{{previousTag}}...{{currentTag}}"
}
```

이 설정을 사용하면 CHANGELOG에 이모지와 한글 섹션 제목이 추가돼요.

### PR에 CHANGELOG 미리보기 추가

`release-please`를 사용하면 Release PR에 자동으로 CHANGELOG 미리보기가 추가돼요. 별도 설정이 필요 없어요.

`standard-version`을 사용하는 경우에는 추가 액션을 사용해서 PR에 코멘트로 CHANGELOG를 달 수 있어요.

```yaml
# .github/workflows/preview-changelog.yml
name: Preview CHANGELOG

on:
  pull_request:
    branches:
      - main

jobs:
  preview:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate preview
        run: |
          npx standard-version --dry-run > changelog-preview.txt

      - name: Comment PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const preview = fs.readFileSync('changelog-preview.txt', 'utf8');
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## CHANGELOG Preview\n\n\`\`\`\n${preview}\n\`\`\``
            });
```

## 트러블슈팅

### 커밋 컨벤션 미준수 문제

팀원들이 Conventional Commits 규칙을 따르지 않으면 CHANGELOG가 제대로 생성되지 않아요.

**해결 방법**

Husky와 commitlint를 사용해서 커밋 메시지를 검증하세요.

```bash
npm install --save-dev @commitlint/cli @commitlint/config-conventional husky
```

```javascript
// commitlint.config.js
module.exports = {
  extends: ["@commitlint/config-conventional"],
};
```

```bash
# Husky 설정
npx husky init
echo "npx --no -- commitlint --edit \$1" > .husky/commit-msg
```

이제 규칙에 맞지 않는 커밋 메시지는 자동으로 거부돼요.

### 권한 오류 (GITHUB_TOKEN)

워크플로우에서 Git 푸시나 Release 생성 시 권한 오류가 발생할 수 있어요.

```
Error: Resource not accessible by integration
```

**해결 방법**

워크플로우 파일에 `permissions`를 명시하세요.

```yaml
permissions:
  contents: write
  pull-requests: write
```

또는 GitHub 저장소 Settings > Actions > General > Workflow permissions에서 "Read and write permissions"를 활성화하세요.

<Callout type="error" title="주의">
  `GITHUB_TOKEN`은 워크플로우가 실행될 때 자동으로 생성돼요. 별도로 시크릿을
  추가할 필요가 없어요.
</Callout>

## 마무리

GitHub Actions로 CHANGELOG를 자동화하면 릴리즈 프로세스가 훨씬 효율적으로 변해요. 핵심 내용을 정리하면 다음과 같아요.

- **Conventional Commits 규칙 준수**: `feat`, `fix`, `docs` 등의 타입으로 커밋 메시지 작성
- **자동화 도구 선택**: 간단한 프로젝트는 standard-version, 팀 프로젝트는 release-please 추천
- **GitHub Actions 워크플로우**: `main` 브랜치 푸시 또는 수동 트리거로 CHANGELOG 자동 생성
- **커밋 메시지 검증**: commitlint로 규칙을 강제하여 일관성 유지

**실무 적용 팁**

1. 처음에는 `release-please`로 시작해서 PR로 릴리즈를 검토하세요
2. 팀원들에게 Conventional Commits 가이드를 공유하세요
3. `.versionrc.json`으로 CHANGELOG 형식을 팀 스타일에 맞게 커스터마이징하세요
4. 릴리즈 노트에 마이그레이션 가이드나 주요 변경 사항을 추가로 작성하세요

이제 수동으로 CHANGELOG를 작성하는 수고를 덜고 코드 작성에 집중하세요!
