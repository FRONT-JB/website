---
title: 프로세스와 스레드의 차이
description: 프로세스와 스레드의 개념과 차이점에 대해 설명합니다.
---

import { Callout } from "fumadocs-ui/components/callout";

<Callout type="info">
**중요도: ⭐⭐⭐⭐⭐**

운영체제의 핵심 개념이며, 멀티태스킹 환경에서 필수적인 지식입니다.

</Callout>

## 기본 개념

### 프로세스 (Process)

**운영체제로부터 자원을 할당받는 작업의 단위**

- 실행 중인 프로그램의 인스턴스
- 독립적인 메모리 공간을 할당받음
- 최소 하나의 스레드(메인 스레드)를 포함

### 스레드 (Thread)

**할당받은 자원을 이용하여 실행되는 실행 흐름의 단위**

- 프로세스 내에서 실행되는 여러 흐름의 단위
- 경량 프로세스(Light Weight Process)라고도 불림
- 프로세스의 자원을 공유하면서 실행

## 메모리 구조 비교

### 프로세스 메모리 구조

```
┌─────────────────┐
│     Stack       │ ← 각 프로세스마다 독립
├─────────────────┤
│     Heap        │ ← 각 프로세스마다 독립
├─────────────────┤
│     Data        │ ← 각 프로세스마다 독립
├─────────────────┤
│     Code        │ ← 각 프로세스마다 독립
└─────────────────┘
```

### 스레드 메모리 구조

```
Process Memory Space
┌─────────────────┐
│ Stack (Thread1) │ ← 각 스레드마다 독립
├─────────────────┤
│ Stack (Thread2) │ ← 각 스레드마다 독립
├─────────────────┤
│     Heap        │ ← 스레드들이 공유
├─────────────────┤
│     Data        │ ← 스레드들이 공유
├─────────────────┤
│     Code        │ ← 스레드들이 공유
└─────────────────┘
```

<Callout type="note">
**메모리 공유 특징**

프로세스 내의 스레드들은 Code, Data, Heap 영역을 공유하지만 Stack 영역은 각자 따로 가지고 있습니다.

</Callout>

## 멀티 프로세스 vs 멀티 스레드

### 멀티 프로세스

**하나의 프로그램을 여러 개의 프로세스로 나누어 각 프로세스가 하나의 작업을 처리하는 방식**

#### 장점

- **안정성**: 하나의 프로세스가 죽어도 다른 프로세스에 영향을 끼치지 않음
- **독립성**: 각 프로세스가 독립적인 메모리 공간을 가짐
- **보안성**: 프로세스 간 메모리 격리로 보안이 좋음

#### 단점

- **높은 자원 사용량**: 더 많은 메모리 공간과 CPU 시간을 차지
- **느린 통신**: IPC(Inter-Process Communication) 필요
- **Context Switching 비용**: 프로세스 전환 시 오버헤드가 큼

### 멀티 스레드

**하나의 프로그램을 여러 개의 스레드로 나누어 각 스레드가 하나의 작업을 처리하는 방식**

#### 장점

- **효율적 자원 사용**: 시스템 자원 소모가 줄어듦
- **빠른 통신**: 메모리를 공유하므로 데이터 교환이 빠름
- **높은 처리량**: 시스템 처리량이 향상됨
- **빠른 Context Switching**: 스레드 전환 비용이 적음

#### 단점

- **복잡한 디버깅**: 디버깅이 까다로움
- **안정성 문제**: 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받음
- **동기화 이슈**: 공유 자원에 대한 동기화 필요
- **데드락**: 상호 배제로 인한 교착상태 발생 가능

## 실제 예시

### 웹 브라우저 - 멀티 프로세스 방식

```
Chrome Browser
├── Main Process (UI, 네트워크 등)
├── Renderer Process (탭1)
├── Renderer Process (탭2)
├── Plugin Process
└── GPU Process
```

### Node.js - 싱글 스레드 + 워커 스레드

```javascript
// 메인 스레드 (이벤트 루프)
const { Worker, isMainThread, parentPort } = require("worker_threads");

if (isMainThread) {
  // 메인 스레드에서 워커 생성
  const worker = new Worker(__filename);
  worker.postMessage(42);

  worker.on("message", (result) => {
    console.log(`Result: ${result}`);
  });
} else {
  // 워커 스레드에서 실행
  parentPort.on("message", (data) => {
    const result = heavyCalculation(data);
    parentPort.postMessage(result);
  });
}
```

## Context Switching

### 프로세스 Context Switching

1. 현재 프로세스의 PCB(Process Control Block) 저장
2. CPU 레지스터, 메모리 맵 등 모든 상태 저장
3. 새로운 프로세스의 PCB 로드
4. 메모리 주소 공간 전환 (비용이 큼)

### 스레드 Context Switching

1. 현재 스레드의 레지스터 상태만 저장
2. 새로운 스레드의 레지스터 상태 로드
3. 메모리 주소 공간은 동일하므로 전환 불필요 (비용이 적음)

<Callout type="info">
**면접 팁**

이 주제에 대해서는 구체적인 예시와 함께 설명할 수 있어야 합니다. 특히 웹 개발 맥락에서 브라우저의 멀티 프로세스 구조나 Node.js의 이벤트 루프와 워커 스레드에 대해 언급하면 좋습니다.

</Callout>
