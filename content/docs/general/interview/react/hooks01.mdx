---
title: "useDeferredValueì™€ useTransition"
description: "Reactì˜ useDeferredValueì™€ useTransition"
---

## Reactì˜ useDeferredValueì™€ useTransitionì€ ë¬´ì—‡ì´ê³  ì–´ë–»ê²Œ ë™ì‘í•˜ë‚˜ìš”?

`useDeferredValue`ì™€ `useTransition`ì€ React 18ì—ì„œ ë„ì…ëœ **Concurrent Features**ë¡œ, UI ì—…ë°ì´íŠ¸ì˜ ìš°ì„ ìˆœìœ„ë¥¼ ì¡°ì ˆí•˜ì—¬ ì‚¬ìš©ì ê²½í—˜ì„ í–¥ìƒì‹œí‚¤ëŠ” í›…ë“¤ì…ë‹ˆë‹¤.

<Callout type="info" title="Concurrent Featuresë€?">

Concurrent FeaturesëŠ” Reactê°€ ì—¬ëŸ¬ ì‘ì—…ì„ ë™ì‹œì— ì²˜ë¦¬í•˜ê³ , ì¤‘ìš”í•œ ì—…ë°ì´íŠ¸ë¥¼ ìš°ì„ ì‹œí•˜ë©°, í•„ìš”ì— ë”°ë¼ ì‘ì—…ì„ ì¼ì‹œ ì¤‘ë‹¨í•˜ê±°ë‚˜ ì¬ê°œí•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” ê¸°ëŠ¥ë“¤ì…ë‹ˆë‹¤.

</Callout>

### useDeferredValue

`useDeferredValue`ëŠ” **ê°’ì˜ ì—…ë°ì´íŠ¸ë¥¼ ì§€ì—°**ì‹œì¼œ ë” ì¤‘ìš”í•œ ì—…ë°ì´íŠ¸ê°€ ë¨¼ì € ì²˜ë¦¬ë˜ë„ë¡ í•©ë‹ˆë‹¤.

```tsx
import { useDeferredValue, useState } from "react";

function SearchResults() {
  const [query, setQuery] = useState("");
  // ê²€ìƒ‰ì–´ ì—…ë°ì´íŠ¸ë¥¼ ì§€ì—°ì‹œí‚´
  const deferredQuery = useDeferredValue(query);

  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
      />

      {/* ì‚¬ìš©ì ì…ë ¥ì€ ì¦‰ì‹œ ë°˜ì˜ */}
      <p>ì…ë ¥ ì¤‘: {query}</p>

      {/* ê²€ìƒ‰ ê²°ê³¼ëŠ” ì§€ì—°ë˜ì–´ ì—…ë°ì´íŠ¸ */}
      <SearchResultsList query={deferredQuery} />
    </div>
  );
}

function SearchResultsList({ query }: { query: string }) {
  // ë¬´ê±°ìš´ ì—°ì‚°ì´ë‚˜ ë§ì€ ë Œë”ë§ì´ í•„ìš”í•œ ì»´í¬ë„ŒíŠ¸
  const results = useMemo(() => {
    if (!query) return [];
    // ë³µì¡í•œ í•„í„°ë§ ë¡œì§
    return heavySearchOperation(query);
  }, [query]);

  return (
    <ul>
      {results.map((result) => (
        <li key={result.id}>{result.title}</li>
      ))}
    </ul>
  );
}
```

### useTransition

`useTransition`ì€ **ìƒíƒœ ì—…ë°ì´íŠ¸ë¥¼ ì „í™˜(transition)** ìœ¼ë¡œ í‘œì‹œí•˜ì—¬ ìš°ì„ ìˆœìœ„ë¥¼ ë‚®ì¶¥ë‹ˆë‹¤.

```tsx
import { useTransition, useState } from "react";

function ProductFilter() {
  const [filter, setFilter] = useState("");
  const [products, setProducts] = useState(allProducts);
  const [isPending, startTransition] = useTransition();

  const handleFilterChange = (newFilter: string) => {
    // ì¦‰ì‹œ ì—…ë°ì´íŠ¸ (ê¸´ê¸‰í•œ ì—…ë°ì´íŠ¸)
    setFilter(newFilter);

    // ì§€ì—° ê°€ëŠ¥í•œ ì—…ë°ì´íŠ¸ (ì „í™˜ìœ¼ë¡œ í‘œì‹œ)
    startTransition(() => {
      const filtered = allProducts.filter((product) =>
        product.name.toLowerCase().includes(newFilter.toLowerCase()),
      );
      setProducts(filtered);
    });
  };

  return (
    <div>
      <input
        value={filter}
        onChange={(e) => handleFilterChange(e.target.value)}
        placeholder="ìƒí’ˆ í•„í„°ë§..."
      />

      {/* ë¡œë”© ìƒíƒœ í‘œì‹œ */}
      {isPending && <div>í•„í„°ë§ ì¤‘...</div>}

      {/* í•„í„°ë§ëœ ê²°ê³¼ */}
      <ProductList products={products} />
    </div>
  );
}
```

### ë‘ í›…ì˜ ì°¨ì´ì ê³¼ ì‚¬ìš© ì‹œê¸°

<Callout type="error" title="í•µì‹¬ ì°¨ì´ì ">

- **useDeferredValue**: ì™¸ë¶€ì—ì„œ ë°›ì€ ê°’(props)ì„ ì§€ì—°ì‹œí‚¬ ë•Œ ì‚¬ìš©
- **useTransition**: ë‚´ê°€ ìƒì„±í•˜ëŠ” ìƒíƒœ ì—…ë°ì´íŠ¸ë¥¼ ì§€ì—°ì‹œí‚¬ ë•Œ ì‚¬ìš©

</Callout>

| íŠ¹ì„±          | useDeferredValue           | useTransition                  |
| ------------- | -------------------------- | ------------------------------ |
| **ì‚¬ìš© ëª©ì ** | ê°’ ìì²´ì˜ ì—…ë°ì´íŠ¸ ì§€ì—°    | ìƒíƒœ ë³€ê²½ í•¨ìˆ˜ì˜ ìš°ì„ ìˆœìœ„ ì¡°ì ˆ |
| **ì œì–´ ëŒ€ìƒ** | ì™¸ë¶€ ê°’ (props, ì™¸ë¶€ ìƒíƒœ) | ë‚´ë¶€ ìƒíƒœ ì—…ë°ì´íŠ¸             |
| **ë°˜í™˜ê°’**    | ì§€ì—°ëœ ê°’                  | [isPending, startTransition]   |
| **ë¡œë”© ìƒíƒœ** | ì œê³µí•˜ì§€ ì•ŠìŒ              | isPending ì œê³µ                 |

### ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œ - íƒ­ ì „í™˜

```tsx
import { useState, useTransition } from "react";

function TabContainer() {
  const [activeTab, setActiveTab] = useState("home");
  const [isPending, startTransition] = useTransition();

  const handleTabChange = (tab: string) => {
    startTransition(() => {
      setActiveTab(tab);
    });
  };

  return (
    <div>
      <div className="tabs">
        {["home", "profile", "settings"].map((tab) => (
          <button
            key={tab}
            onClick={() => handleTabChange(tab)}
            className={`tab ${activeTab === tab ? "active" : ""} ${
              isPending ? "loading" : ""
            }`}
          >
            {tab.charAt(0).toUpperCase() + tab.slice(1)}
          </button>
        ))}
      </div>

      {/* íƒ­ ì „í™˜ ì¤‘ì—ë„ ì‚¬ìš©ì ìƒí˜¸ì‘ìš©ì€ ì°¨ë‹¨ë˜ì§€ ì•ŠìŒ */}
      {isPending && <div className="tab-loading">ì „í™˜ ì¤‘...</div>}

      <div className="tab-content">
        {activeTab === "home" && <HomeContent />}
        {activeTab === "profile" && <ProfileContent />}
        {activeTab === "settings" && <SettingsContent />}
      </div>
    </div>
  );
}
```

### ë³µì¡í•œ ì‹¤ì œ ì˜ˆì‹œ - ë°ì´í„° í…Œì´ë¸”

```tsx
import { useState, useMemo, useTransition, useDeferredValue } from "react";

interface User {
  id: number;
  name: string;
  email: string;
  department: string;
}

function UserTable({ users }: { users: User[] }) {
  const [searchTerm, setSearchTerm] = useState("");
  const [sortField, setSortField] = useState<keyof User>("name");
  const [isPending, startTransition] = useTransition();

  // ê²€ìƒ‰ì–´ëŠ” ì¦‰ì‹œ ì—…ë°ì´íŠ¸í•˜ë˜, ì‹¤ì œ í•„í„°ë§ì€ ì§€ì—°
  const deferredSearchTerm = useDeferredValue(searchTerm);

  const filteredAndSortedUsers = useMemo(() => {
    let result = users;

    // ê²€ìƒ‰ í•„í„°ë§
    if (deferredSearchTerm) {
      result = result.filter(
        (user) =>
          user.name.toLowerCase().includes(deferredSearchTerm.toLowerCase()) ||
          user.email.toLowerCase().includes(deferredSearchTerm.toLowerCase()),
      );
    }

    // ì •ë ¬
    return result.sort((a, b) => {
      return a[sortField].toString().localeCompare(b[sortField].toString());
    });
  }, [users, deferredSearchTerm, sortField]);

  const handleSortChange = (field: keyof User) => {
    startTransition(() => {
      setSortField(field);
    });
  };

  const isStale = searchTerm !== deferredSearchTerm || isPending;

  return (
    <div>
      {/* ê²€ìƒ‰ ì…ë ¥ì€ í•­ìƒ ë°˜ì‘ì  */}
      <input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="ì‚¬ìš©ì ê²€ìƒ‰..."
        className="search-input"
      />

      {/* ë¡œë”© ìƒíƒœ í‘œì‹œ */}
      {isStale && <div className="loading-overlay">ì²˜ë¦¬ ì¤‘...</div>}

      <table className={`user-table ${isStale ? "stale" : ""}`}>
        <thead>
          <tr>
            {(["name", "email", "department"] as const).map((field) => (
              <th
                key={field}
                onClick={() => handleSortChange(field)}
                className={`sortable ${sortField === field ? "active" : ""}`}
              >
                {field.charAt(0).toUpperCase() + field.slice(1)}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {filteredAndSortedUsers.map((user) => (
            <tr key={user.id}>
              <td>{user.name}</td>
              <td>{user.email}</td>
              <td>{user.department}</td>
            </tr>
          ))}
        </tbody>
      </table>

      <div className="results-count">
        {filteredAndSortedUsers.length}ëª…ì˜ ì‚¬ìš©ì
      </div>
    </div>
  );
}
```

<Callout type="info" title="ì–¸ì œ ì‚¬ìš©í•´ì•¼ í• ê¹Œ?">

**useDeferredValue ì‚¬ìš© ì‹œê¸°:**

- ê²€ìƒ‰ ê²°ê³¼, í•„í„°ë§ ê²°ê³¼ ë“± ì¦‰ì‹œ ì—…ë°ì´íŠ¸í•  í•„ìš”ê°€ ì—†ëŠ” ê°’
- ì™¸ë¶€ì—ì„œ ë°›ì€ propsë‚˜ ê°’ì„ ê¸°ë°˜ìœ¼ë¡œ ë¬´ê±°ìš´ ì—°ì‚°ì„ í•  ë•Œ

**useTransition ì‚¬ìš© ì‹œê¸°:**

- íƒ­ ì „í™˜, í˜ì´ì§€ ë„¤ë¹„ê²Œì´ì…˜ ë“± ì‚¬ìš©ìê°€ ê¸°ë‹¤ë¦´ ìˆ˜ ìˆëŠ” ì—…ë°ì´íŠ¸
- ëŒ€ëŸ‰ì˜ ë°ì´í„° ì²˜ë¦¬ë‚˜ ë³µì¡í•œ ì—°ì‚°ì„ í¬í•¨í•œ ìƒíƒœ ë³€ê²½

</Callout>

### ì„±ëŠ¥ ìµœì í™” íŒ

```tsx
// ğŸ¯ Good: Concurrent Featuresì™€ ë©”ëª¨ì´ì œì´ì…˜ í•¨ê»˜ ì‚¬ìš©
function OptimizedComponent({ data }) {
  const [query, setQuery] = useState("");
  const deferredQuery = useDeferredValue(query);
  const [isPending, startTransition] = useTransition();

  // ë¬´ê±°ìš´ ì—°ì‚°ì€ ë©”ëª¨ì´ì œì´ì…˜
  const processedData = useMemo(() => {
    return heavyDataProcessing(data, deferredQuery);
  }, [data, deferredQuery]);

  const handleUpdate = (newData) => {
    startTransition(() => {
      updateData(newData);
    });
  };

  return (
    <div>
      <input value={query} onChange={(e) => setQuery(e.target.value)} />
      {isPending && <Spinner />}
      <ResultsList data={processedData} />
    </div>
  );
}
```
