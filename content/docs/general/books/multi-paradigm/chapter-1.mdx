---
title: 멀티패러다임 프로그래밍 1
description: 멀티패러다임 프로그래밍의 기본 개념
---

## 제네레이터 기본 문법

- 제네레이터는 명령 스타일로 이터레이터를 작성할 수 있게 해주는 문법이다.
- `function*` 키워드로 정의되며 호출시 곧바로 실행되지 않고 이터레이터 객체를
  반환한다.
- `yield`와 `next()`를 사용해 제네레이터 함수를 실행한다.

  ```js
  function* generator() {
    yield 1;
    yield 2;
    yield 3;
  }

  const iter = generator();

  console.log(iter.next()); // { value: 1, done: false }
  console.log(iter.next()); // { value: 2, done: false }
  console.log(iter.next()); // { value: 3, done: false }
  console.log(iter.next()); // { value: undefined, done: true }
  ```

- `yield*`는 제너레이터 함수 안에서 이터러블을 순회하며 해당 이터러블이 제공하는 요소들을 순차적으로 반환해준다.

  ```js
  function generator() {
    yield 1;
    yield* [2, 3];
    yield 4;
  }

  const iter = generator();

  console.log(iter.next()); // { value: 1, done: false }
  console.log(iter.next()); // { value: 2, done: false }
  console.log(iter.next()); // { value: 3, done: false }
  console.log(iter.next()); // { value: 4, done: false }
  console.log(iter.next()); // { value: undefined, done: true }
  ```

<Callout type="info" title="yield*의 동작 원리">

1. 처음 iter.next()를 호출하면 제네레이터 함수가 실행된다.
2. yield 1이 실행되고 1이 반환된다.
3. yield\* [2, 3]이 실행되고 배열[2, 3]의 각 요소를 차례대로 반환한다.
4. yield 4가 실행되고 4가 반환된다.
5. yield undefined가 실행되고 undefined가 반환된다.

</Callout>

---

## 자바스크립트에서 반복자 패턴 사례: 이터레이션 프로토콜

- 만일 어떤 객체가 이터레이터를 반환하는 `[Symbol.iterator]() {return { next() {...}}}` 메서드를 가지고 있다면 이터러블이다.
  이터러블 객체는 `for...of문`, `전개 연산자`, `구조 분해` 등 다양한 기능과 함께 사용할 수 있다.

<Callout type="info" title="이터레이션 프로토콜">

대표적으로 배열, 문자열, Map, Set, TypedArray, arguments, NodeList, HTMLCollection 등이 이터러블이다.

</Callout>
