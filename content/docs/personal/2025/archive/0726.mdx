---
title: "7월 26일"
description: "디자인 패턴 기초와 생성 패턴"
---

## 오늘 배운 것 (TIL)

디자인 패턴 기초와 생성 패턴

## 핵심 요약 (TL;DR)

SOLID 원칙을 기반으로 객체 생성의 책임을 분리하고 유연성을 높이는 방법을 학습.

## SOLID 원칙 정리

### SRP (Single Responsibility Principle) - 단일 책임 원칙

- **핵심**: 한 객체는 하나의 책임만 가져야 한다
- **책임 = 변경의 이유**
- 실무에서는 객체가 너무 많아져서 지키지 않는 경우도 있음

### OCP (Open Closed Principle) - 개방 폐쇄 원칙

- **핵심**: 확장에는 열려있고, 변경에는 닫혀있어야 한다
- 새로운 기능 추가 시 기존 코드 수정 금지

### LSP (Liskov Substitution Principle) - 리스코프 치환 원칙

- **핵심**: 자식 클래스는 부모 클래스 역할을 대체할 수 있어야 한다
- **확인법**: 부모 클래스 자리에 자식 클래스를 넣어도 타입 에러가 나지 않아야 함

### ISP (Interface Segregation Principle) - 인터페이스 분리 원칙

- **핵심**: 사용하지 않는 인터페이스는 구현하지 말아야 한다
- 인터페이스를 쪼개서 필요한 만큼만 implements

### DIP (Dependency Inversion Principle) - 의존성 역전 원칙

- **핵심**: 추상성이 높은 클래스와 의존 관계를 맺는다
- 상속 대신 합성, interface/abstract class를 매개변수로 사용

---

## 생성 패턴 (Creational Patterns)

### 1. 싱글턴 (Singleton)

**목적**: 하나의 인스턴스만 존재함을 보장

**특징**:

- 생성자를 private으로 (JS에서는 symbol 사용)
- **문제점**: SRP 위반, 강결합으로 테스트 어려움

### 2. 심플 팩토리 (Simple Factory)

**목적**: 객체를 반환하는 함수

**특징**:

- 조건문에 따라 다른 객체 반환
- **문제점**: SRP, OCP 위반

### 3. 팩토리 메서드 (Factory Method)

**목적**: 상위 클래스가 인터페이스 역할, 하위 클래스에서 구체적 구현

**장점**:

- 하위 클래스를 다양하게 만들어 OCP, SRP 충족
- 상속을 통해 다른 객체 생성 가능

**구조**:

```
Creator (상위)
├── ConcreteCreatorA
└── ConcreteCreatorB
```

### 4. 추상 팩토리 (Abstract Factory)

**목적**: 여러 팩토리의 그룹

**핵심 아이디어**:

- 팩토리 메서드 패턴에서 확장
- **일관성 보장**: Chrome 메뉴에 IE 히스토리가 생기는 등의 상황 방지
- 브라우저별로 그림판, 메뉴, 히스토리의 세트가 함께 생성됨

---

## 패턴별 SOLID 원칙 적용도

| 패턴          | SRP | OCP | 비고                          |
| ------------- | --- | --- | ----------------------------- |
| 싱글턴        | ❌  | -   | 인스턴스 관리 + 비즈니스 로직 |
| 심플 팩토리   | ❌  | ❌  | 조건문으로 모든 객체 생성     |
| 팩토리 메서드 | ✅  | ✅  | 하위 클래스로 확장            |
| 추상 팩토리   | ✅  | ✅  | 팩토리 메서드 패턴 확장       |

---


## 참고 자료

- ZeroCho 디자인 패턴
